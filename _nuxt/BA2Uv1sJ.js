import{C as F}from"./DFAZJfCD.js";import{c as p,a7 as H,b as L,a8 as h,a9 as S,aa as V,r as U,ab as P,ac as $,ad as q,g as M,ae as z,af as I,ag as G,M as W,i as J,ah as Q,d as X,E as Y,x as Z,G as x,l as K,j as A,m as k,p as aa}from"./CPkfughN.js";import{q as ea}from"./DQhS8ANw.js";import"./hcmm1ruR.js";const ta={trailing:!0};function sa(a,e=25,n={}){if(n={...ta,...n},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let c,t,r=[],s,D;const l=(y,u)=>(s=ra(a,y,u),s.finally(()=>{if(s=null,n.trailing&&D&&!t){const v=l(y,D);return D=null,v}}),s);return function(...y){return s?(n.trailing&&(D=y),s):new Promise(u=>{const v=!t&&n.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const d=n.leading?c:l(this,y);for(const m of r)m(d);r=[]},e),v?(c=l(this,y),u(c)):r.push(u)})}}async function ra(a,e,n){return await a.apply(e,n)}const na=Symbol.for("nuxt:client-only"),ca=a=>a==="defer"||a===!1;function la(...a){var w;const e=typeof a[a.length-1]=="string"?a.pop():void 0;typeof a[0]!="string"&&typeof a[0]!="object"&&!(typeof a[0]=="function"&&typeof a[1]=="function")&&a.unshift(e);let[n,c,t={}]=a;const r=p(()=>H(n));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const s=L(),D=()=>h.value,l=(i,_,C)=>{if(_.isHydrating)return _.payload.data[i];if(C.cause!=="refresh:manual"&&C.cause!=="refresh:hook")return _.static.data[i]};t.server??(t.server=!0),t.default??(t.default=D),t.getCachedData??(t.getCachedData=l),t.lazy??(t.lazy=!1),t.immediate??(t.immediate=!0),t.deep??(t.deep=h.deep),t.dedupe??(t.dedupe="cancel"),t._functionName,s._asyncData[r.value];const y=t.getCachedData(r.value,s,{cause:"initial"});(w=s._asyncData[r.value])!=null&&w._init||(s._asyncData[r.value]=R(s,r.value,c,t,y));const u=s._asyncData[r.value];u._deps++;const v=()=>s._asyncData[r.value].execute({cause:"initial",dedupe:t.dedupe}),d=t.server!==!1&&s.payload.serverRendered;{let i=function(o){const f=s._asyncData[o];f!=null&&f._deps&&(f._deps--,f._deps===0&&(f==null||f._off(),f._init=!1,N(s,o),f.execute=()=>Promise.resolve(),s._asyncData[o].data.value=h.value))};const _=I();if(_&&d&&t.immediate&&!_.sp&&(_.sp=[]),_&&!_._nuxtOnBeforeMountCbs){_._nuxtOnBeforeMountCbs=[];const o=_._nuxtOnBeforeMountCbs;G(()=>{o.forEach(f=>{f()}),o.splice(0,o.length)}),W(()=>o.splice(0,o.length))}const C=_&&(_._nuxtClientOnly||J(na,!1));d&&s.isHydrating&&(u.error.value||y!=null)?(u.pending.value=!1,u.status.value=u.error.value?"error":"success"):_&&!C&&(s.payload.serverRendered&&s.isHydrating||t.lazy)&&t.immediate?_._nuxtOnBeforeMountCbs.push(v):t.immediate&&v();const E=z();if(t.watch){const o=S(t.watch,()=>{u._execute({cause:"watch",dedupe:t.dedupe})},{flush:"post"});E&&V(()=>o())}const T=S(r,(o,f)=>{var O,B;const j=((O=s._asyncData[f])==null?void 0:O.data.value)!==h.value;f&&i(f),(B=s._asyncData[o])!=null&&B._init||(s._asyncData[o]=R(s,o,c,t,t.getCachedData(o,s,{cause:"initial"}))),s._asyncData[o]._deps++,(t.immediate||j)&&s._asyncData[o].execute({cause:"initial",dedupe:t.dedupe})},{flush:"sync"});E&&V(()=>{T(),i(r.value)})}const m={data:b(()=>{var i;return(i=s._asyncData[r.value])==null?void 0:i.data}),pending:b(()=>{var i;return(i=s._asyncData[r.value])==null?void 0:i.pending}),status:b(()=>{var i;return(i=s._asyncData[r.value])==null?void 0:i.status}),error:b(()=>{var i;return(i=s._asyncData[r.value])==null?void 0:i.error}),refresh:(...i)=>s._asyncData[r.value].execute(...i),execute:(...i)=>s._asyncData[r.value].execute(...i),clear:()=>N(s,r.value)},g=Promise.resolve(s._asyncDataPromises[r.value]).then(()=>m);return Object.assign(g,m),g}function b(a){return p({get(){var e;return(e=a())==null?void 0:e.value},set(e){const n=a();n&&(n.value=e)}})}function N(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=h.errorValue),a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=h.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]&&(a._asyncDataPromises[e].cancelled=!0),a._asyncDataPromises[e]=void 0)}function ua(a,e){const n={};for(const c of e)n[c]=a[c];return n}function R(a,e,n,c,t){var y;(y=a.payload._errors)[e]??(y[e]=h.errorValue);const r=n,s=c.deep?U:P,D=t!=null,l={data:s(D?t:c.default()),pending:P(!D),error:$(a.payload._errors,e),status:P("idle"),execute:(u={})=>{if(a._asyncDataPromises[e]){if(ca(u.dedupe??c.dedupe))return a._asyncDataPromises[e];a._asyncDataPromises[e].cancelled=!0}if(u.cause==="initial"||a.isHydrating){const d=u.cause==="initial"?t:c.getCachedData(e,a,{cause:u.cause??"refresh:manual"});if(d!=null)return a.payload.data[e]=l.data.value=d,l.error.value=h.errorValue,l.status.value="success",Promise.resolve(d)}l.pending.value=!0,l.status.value="pending";const v=new Promise((d,m)=>{try{d(r(a))}catch(g){m(g)}}).then(async d=>{if(v.cancelled)return a._asyncDataPromises[e];let m=d;c.transform&&(m=await c.transform(d)),c.pick&&(m=ua(m,c.pick)),a.payload.data[e]=m,l.data.value=m,l.error.value=h.errorValue,l.status.value="success"}).catch(d=>{if(v.cancelled)return a._asyncDataPromises[e];l.error.value=q(d),l.data.value=M(c.default()),l.status.value="error"}).finally(()=>{v.cancelled||(l.pending.value=!1,delete a._asyncDataPromises[e])});return a._asyncDataPromises[e]=v,a._asyncDataPromises[e]},_execute:sa((...u)=>l.execute(...u),0,{leading:!0}),_default:c.default,_deps:0,_init:!0,_hash:void 0,_off:a.hook("app:data:refresh",async u=>{(!u||u.includes(e))&&await l.execute({cause:"refresh:hook"})})};return l}function ia(){const{locale:a}=Q();return{fetch:async()=>{const{data:e}=await la(`layout-data-${a.value}`,()=>ea("layout").path(`/layout/${a.value}`).first().then(n=>(n==null?void 0:n.body)||{}),{watch:[a]});return e}}}const ya=X({__name:"default",async setup(a){let e,n;const{fetch:c}=ia(),t=([e,n]=Y(()=>c()),e=await e,n(),e);return aa("layoutData",t),(r,s)=>(A(),Z("div",null,[x(M(F),null,{default:K(()=>[k(r.$slots,"default")]),_:3})]))}});export{ya as default};
