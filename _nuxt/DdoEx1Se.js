import{C as B}from"./COtWEHUb.js";import{b as O,a6 as d,r as m,a7 as E,a8 as M,a9 as S,aa as C,ab as V,ac as H,g as w,ad as R,ae as j,af as z,ag as N,d as $,E as q,x,G as I,l as K,j as T,m as F,p as G}from"./bhkxU0MC.js";import{q as L}from"./Cxz8N9Q1.js";import"./CeJ8ZBlK.js";const U=t=>t==="defer"||t===!1;function J(...t){var g;const r=typeof t[t.length-1]=="string"?t.pop():void 0;typeof t[0]!="string"&&t.unshift(r);let[e,l,a={}]=t;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const s=O(),_=l,P=()=>d.value,b=()=>s.isHydrating?s.payload.data[e]:s.static.data[e];a.server=a.server??!0,a.default=a.default??P,a.getCachedData=a.getCachedData??b,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??d.deep,a.dedupe=a.dedupe??"cancel";const f=a.getCachedData(e,s),h=f!=null;if(!s._asyncData[e]||!a.immediate){(g=s.payload._errors)[e]??(g[e]=d.errorValue);const i=a.deep?m:E;s._asyncData[e]={data:i(h?f:a.default()),pending:m(!h),error:M(s.payload._errors,e),status:m("idle"),_default:a.default}}const n={...s._asyncData[e]};delete n._default,n.refresh=n.execute=(i={})=>{if(s._asyncDataPromises[e]){if(U(i.dedupe??a.dedupe))return s._asyncDataPromises[e];s._asyncDataPromises[e].cancelled=!0}if(i._initial||s.isHydrating&&i._initial!==!1){const c=i._initial?f:a.getCachedData(e,s);if(c!=null)return Promise.resolve(c)}n.pending.value=!0,n.status.value="pending";const u=new Promise((c,o)=>{try{c(_(s))}catch(y){o(y)}}).then(async c=>{if(u.cancelled)return s._asyncDataPromises[e];let o=c;a.transform&&(o=await a.transform(c)),a.pick&&(o=W(o,a.pick)),s.payload.data[e]=o,n.data.value=o,n.error.value=d.errorValue,n.status.value="success"}).catch(c=>{if(u.cancelled)return s._asyncDataPromises[e];n.error.value=H(c),n.data.value=w(a.default()),n.status.value="error"}).finally(()=>{u.cancelled||(n.pending.value=!1,delete s._asyncDataPromises[e])});return s._asyncDataPromises[e]=u,s._asyncDataPromises[e]},n.clear=()=>Q(s,e);const D=()=>n.refresh({_initial:!0}),p=a.server!==!1&&s.payload.serverRendered;{const i=R();if(i&&p&&a.immediate&&!i.sp&&(i.sp=[]),i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;j(()=>{o.forEach(y=>{y()}),o.splice(0,o.length)}),z(()=>o.splice(0,o.length))}p&&s.isHydrating&&(n.error.value||f!=null)?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):i&&(s.payload.serverRendered&&s.isHydrating||a.lazy)&&a.immediate?i._nuxtOnBeforeMountCbs.push(D):a.immediate&&D();const u=V();if(a.watch){const o=S(a.watch,()=>n.refresh());u&&C(o)}const c=s.hook("app:data:refresh",async o=>{(!o||o.includes(e))&&await n.refresh()});u&&C(c)}const v=Promise.resolve(s._asyncDataPromises[e]).then(()=>n);return Object.assign(v,n),v}function Q(t,r){r in t.payload.data&&(t.payload.data[r]=void 0),r in t.payload._errors&&(t.payload._errors[r]=d.errorValue),t._asyncData[r]&&(t._asyncData[r].data.value=void 0,t._asyncData[r].error.value=d.errorValue,t._asyncData[r].pending.value=!1,t._asyncData[r].status.value="idle"),r in t._asyncDataPromises&&(t._asyncDataPromises[r]&&(t._asyncDataPromises[r].cancelled=!0),t._asyncDataPromises[r]=void 0)}function W(t,r){const e={};for(const l of r)e[l]=t[l];return e}function X(){const{locale:t}=N();return{fetch:async()=>{const{data:r}=await J(`layout-data-${t.value}`,()=>L("layout").path(`/layout/${t.value}`).first().then(({body:e})=>e),{watch:[t]});return r}}}const aa=$({__name:"default",async setup(t){let r,e;const{fetch:l}=X(),a=([r,e]=q(()=>l()),r=await r,e(),r);return G("layoutData",a),(s,_)=>(T(),x("div",null,[I(w(B),null,{default:K(()=>[F(s.$slots,"default")]),_:3})]))}});export{aa as default};
